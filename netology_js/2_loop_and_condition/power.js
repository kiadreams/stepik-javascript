/*
 * Необходимо внести изменения в уже реализованный алгоритм так чтобы:
 * - возведение в степень осуществлялось быстрее чем это реализовано сейчас
 * - по возможности избавиться от рекурсии
 */
const pow = function (num, exp) {
    if (exp <= 0) {
      return 1;
    }
    let powNum = 1;
    for (let i = 1; i <= exp; i++) {
        powNum *= num;
        
    }
    return powNum;
    // const negative = num < 0 && exp % 2 > 0 ? -1 : 1;
  
    // num *= negative;
  
    // return negative * num * pow(num, exp - 1);
};


/*
 * В данном задании мы закрепляем то, что мы узнали о функциях (о рекурсиях в частности) и циклах (for и while).
 * А также ещё раз затронем тему алгоритмов и сложностей алгоритмов, которые сопровождают программистов в их обычных задачах.
 * От нас ожидается что мы:
 * - перепишем код так, что функция pow для, например, 10 в степени 48 будет не 48 раз вызывать саму себя, а намного меньше
 * - откажемся от рекурсии вообще потому, что это может быть опасно, если допустить ошибку при реализации, а вместо
 *   этого реализуем что-то, что более безопасно и более понятно даже для новичков в программировании.
 * И чтобы добиться ожидаемого результата сначала давайте попробуем улучшить алгоритмическую сложность pow.
 * При той реализации алгоритмическая сложность функции равна O(n) (читается как "о от эн").
 * То есть для 10 в степени 48 наша функция будет перемножать число 10 сорок восемь раз. А если бы мы могли вычислить 10 в степени 12407?
 * Воспользуемся явной подсказкой о свойствах степеней, которые представлены в описании к заданию, чтобы наш алгоритм работал быстрее. То есть:
 * 1) (10 в степени 48) равно (10 в степени 24) в степени 2
 * 2) (10 в степени 55) равно (10 в степени 40) умножить на (10 в степени 15)
 * Более понятно, что чтобы 10 возвести в степень 55, необходимо:
 * 1. 10 возводить в степень, кратную 2-м до тех пор, пока эта кратная степень меньше, чем искомая степень (55)
 * 2. Как только мы достигнем степени, кратной 2-м и меньше 55, необходимо от 55 отнять ту кратную 2-м степень (вычислить разницу)
 * 3. Возвести 10 в степень, которая получилась из разности
 * 4. Два результата вычислений перемножить и вернуть из функции
 * 
 * Заведём переменную, где мы будем учитывать кратность 2-м и сравнивать эту переменную с искомой степенью
 * 
 * let step = 2;
 * 
 * Заведём переменную, которая будет аккумулировать реультат, который в конце вернём из функции
 * 
 * let result = num;
 * 
 * Возводим в степень, кратную 2-м до тех пор, пока эта степень меньше искомой степени
 * 
 * while (step < exp) {
 *   result *= result;
 *   step *= 2;
 * }
 * 
 * Отлично! В нашем примере с 10 в степени 55 мы на данном этапе логики получим, что 10 возведена в степень 32.
 * Далее мы должны возвести 10 в степень 23 (потому что 55-32=23)
 * 
 * const diff = exp - step / 2;
 * 
 * Для этого воспользуемся циклом for
 * 
 * for (let i = 0; i < exp - step / 2; i++) {
 *   result *= num;
 * }
 * 
 * И всё. Можем вернуть результат
 * 
 * return negative * result;
 */
export const pow = function (num, exp) {
    if (exp <= 0) {
      return 1;
    }
  
    const negative = num < 0 && exp % 2 > 0 ? -1 : 1;
  
    num *= negative;
  
    let step = 2;
    let result = num;
  
    while (step < exp) {
      result *= result;
      step *= 2;
    }
  
    const diff = exp - step / 2;
  
    for (let i = 0; i < diff; i++) {
      result *= num;
    }
  
    return negative * result;
  };
  /*
   * Для такой реализации алгоритмическая сложность составляет O(log n) (читается как "о от лог эн").
   * Алгоритмы с такой сложностью работают быстрее, чем алгоритмы со сложностью O(n).
   * 
   * Хоть мы и отказались от рекурсии, но решение с рекурсией работало бы ещё быстрей.
   * Потому что для степени, которую мы получаем от разности, мы заново вычисляем результат от возведения в степень, кратную 2-м.
   * То есть для степени 23 мы быстрее бы вычислили промежуточный результат, который был бы возведен в степень 16.
   * Потом нашли бы разницу 23-16=7. Затем – для степени 7. И так далее, пока разность степеней не достигла бы 0.
   * Это выглядит вот так (вместо цикла for вернём рекурсию):
   * 
   * if (exp <= 0) {
   *   return 1;
   * }
   * 
   * const negative = num < 0 && exp % 2 > 0 ? -1 : 1;
   * 
   * num *= negative;
   * 
   * let step = 2;
   * let result = num;
   * 
   * while (step < exp) {
   *   result *= result;
   *   step *= 2;
   * }
   * 
   * result *= pow(num, exp - step / 2);
   * 
   * return negative * result;
   * 
   * Но как было сказано выше, использовать рекурсии опасно или же нужно очень чётко представлять, когда и как выйти из рекурсии.
   * Код, который мы переписали, легче читать и понимать.
   */


let result = pow(2, 3);

console.log(result);

result = pow(-10, 5);
console.log(result);

result = pow(-3, 4);
console.log(result);