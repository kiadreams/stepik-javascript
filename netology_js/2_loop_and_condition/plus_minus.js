const complexCalc = function (count) {
    const promise = new Promise((resolve, reject) => {
        function fib(n) {
            return n <= 1 ? n : fib(n - 1) + fib(n - 2);
        }
        resolve(fib(count));
    });



    /*
     * Необходимо реализовать функциональность, которая,
     * запуская функцию Фибоначчи, не будет блокировать
     * выполнение следующей функциональности. При этом
     * следует учитывать, что выполнение функции Фибоначчи
     * может аварийно остановить всю программу.
     */
    return promise;
};


// Проверка кода выполнения задачи!!!!

console.log("Основная логика что-то выполняет здесь");

complexCalc(8).then((result) => console.log(result));

console.log("Основная логика тоже что-то выполняет здесь");

complexCalc(41).then((result) => console.log(result));

console.log("Основная логика опять что-то выполняет здесь");

complexCalc(25000)
    .then((result) => console.log(result))
    .catch((error) => {
        console.log("Произошла ошибка:");
        console.log("Тип ошибки:", error.name);
        console.log("Описание ошибки:", error.message);
    });




// // Решение эксперта!!!
// export const complexCalc = function (count) {
//     function fib(n) {
//         return n <= 1 ? n : fib(n - 1) + fib(n - 2);
//     }

//     /*
//      * Как программисты говорят, JavaScript выполняется в одном потоке.
//      * Было бы здорово, если бы можно было распараллелить выполнение длительных функций с
//      * остальной быстрой логикой. Вследствие однопоточности, пришлось разработать 
//      * способы, которые позволяют "отложить" выполнение длительных функций, чтобы они
//      * не блокировали остальную логику программы.
//      * Для решения этой проблемы можно применить Promise в случае с функцией 
//      * Фибоначчи. Promise будет выступать в качестве обертки над функцией Фибоначчи. 
//      * Когда интерпретатор JavaScript дойдет до выполнения этого кода (runtime), он 
//      * отложит выполнение обертки, выполнит остальной код, который не обернут Promise, 
//      * и затем выполнит функциональность, находящуюся внутри обертки.
//      * Однако возникают вопросы: как вернуть результат выполнения изнутри такой 
//      * обертки и что делать, если функциональность аварийно остановится?
//      * Для этого Promise ожидает, что внутри него после завершения выполнения кода,
//      * который помещен в него, будет вызвана либо функция resolve (в которую можно 
//      * передать результат), что указывает на успешное выполнение и получение результата
//      * (если он есть), либо функция reject (в которую можно передать объект ошибки), что 
//      * указывает на возникновение ошибки, которую можно обработать. Если не вызывать 
//      * ни resolve, ни reject внутри промиса, это будет означать, что функциональность все 
//      * еще выполняется, и Promise будет ожидать выполнения бесконечно.
//      * Для получения результата успешного выполнения через некоторое время (с 
//      * помощью метода then, доступного у Promise) и/или для обработки ошибок (с 
//      * помощью метода catch, доступного у Promise), можно использовать такой Promise в
//      * качестве результата.
//      */
//     return new Promise((resolve, reject) => {
//         try {
//             const result = fib(count);

//             resolve(result);
//         } catch (error) {
//             reject(error);
//         }
//     });
// };